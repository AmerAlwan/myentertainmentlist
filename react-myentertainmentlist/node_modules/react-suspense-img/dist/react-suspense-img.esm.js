import invariant from 'invariant';
import { createElement } from 'react';

/**
 * Given a value, determine if it's a promise.
 *
 * @returns true if the value is a promise, false otherwise.
 *
 * @param promise the value to check if it's a promise
 */
var isPromise = function isPromise(promise) {
  return !!promise && typeof promise.then === 'function';
};

/**
 * A simple resource to load images and suspend with React Concurrent mode.
 *
 * This is currently a pretty naive implementation that is inspired by a few
 * early demo apps and the Relay implementation. It has an infinite "cache"
 * size and relies on loading an image via JavaScript into the browser's cache.
 * Since the image itself is not stored in the internal resource's cache the
 * value is simply a boolean. There are likely many improvements that can be
 * made but without a lot of real world examples and use cases it's hard to
 * tell what needs to be more robust or where there may be edge cases.
 */

var Resource = function Resource() {
  var _this = this;

  /**
   * Read an image by source from the cache. If it's cached, the source will
   * be returned. If it's not, a promise will be thrown. If it was attempted
   * but an error occurred an error will be thrown.
   *
   * @returns the source string if loaded, can also throw a promise and error.
   *
   * @param src the image source to read
   */
  this.read = function (src) {
    var cachedValue = _this._cache[src]; // 1. Check if the request to load the image is already in-flight or an
    // error has already occurred trying to load it.

    if (isPromise(cachedValue) || cachedValue instanceof Error) {
      throw cachedValue;
    } // 2. If it exists in the cache, the image has already been loaded.


    if (cachedValue === true) {
      return src;
    } // 3. It doesn't exist so it needs to be fetched. Ideally, this line is
    // never hit because that means the image was never preloaded.


    !!cachedValue ? process.env.NODE_ENV !== "production" ? invariant(false, "An image was loaded that wasn't preloaded.\n" + ("Consider adding `resource.preloadImage(\"" + src + "\")`") + (" before using with <Img src=\"" + src + "\" />")) : invariant(false) : void 0;

    _this.preloadImage(src);

    throw _this._cache[src];
  };
  /**
   * Preload an image by source. Call this before trying to read an image.
   *
   * @param src the image source to load
   */


  this.preloadImage = function (src) {
    var cachedValue = _this._cache[src]; // 1. Check if the request to load the image is already in-flight or an
    // error has already occurred trying to load it.

    if (isPromise(cachedValue) || cachedValue instanceof Error) {
      return cachedValue;
    } // 2. If it exists in the cache, the image has already been loaded.


    if (cachedValue === true) {
      return src;
    }

    var promise = new Promise(function (resolve, reject) {
      var img = new Image();

      img.onload = function () {
        _this._cache[src] = true;
        resolve(src);
      };

      img.onerror = function () {
        _this._cache[src] = new Error("An error occurred loading the image: \"" + src + "\"");
        reject();
      };

      img.src = src;
    });
    _this._cache[src] = promise;
    return promise;
  };
  /**
   * Clear every image from the resource cache.
   */


  this.clear = function () {
    _this._cache = {};
  };

  this._cache = {};
}; // Initialize a single global resource for all images.


var resource =
/*#__PURE__*/
new Resource();

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * Renders an image. If the image has not loaded yet it will suspend. If there
 * is an error while the image loads it will throw.
 *
 * @param props standard image attributes
 */

var Img = function Img(props) {
  var src = props.src,
      alt = props.alt,
      rest = _objectWithoutPropertiesLoose(props, ["src", "alt"]);

  var loadedSrc = resource.read(src);
  return createElement("img", Object.assign({}, rest, {
    alt: alt,
    src: loadedSrc
  }));
};

export { Img, resource };
//# sourceMappingURL=react-suspense-img.esm.js.map
